<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0">
   <title>Data Structures</title>
   <link rel="stylesheet" href="styles.css">
   <script type="text/javascript" id="MathJax-script" async
   src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
   </script>
</head>
<body>
   <h1>Data Strucutres and Applications</h1>
   <hr>

   <pre class="prettyprint">
//insertion sort
#include &lt;stdio.h&gt;

int main() {
   int num_of_elements = 0;
   scanf("%d", &num_of_elements);
      
   int array[num_of_elements];
   
   for( int i = 0; i < num_of_elements; i++) {
      scanf("%d", &array[i]);
   }
      
   //array has been loaded
   for(int i = 1; i < num_of_elements; i++) {
      int j = ( i - 1 );
      int key = array[i];
   
      while( array[j] > key && ( j >= 0 )) {
         array[j+1] = array[j];
         array[j] = key;
         j--;
      }

      for(int i = 0; i < num_of_elements; i++) {
         printf("%d ", array[i]);
      }
      printf("\n");
   }
}
   </pre>

   <div class="description">
      <span>Insertion Sort</span>
      A loop invariant can be used to prove the validity of the 
      insertion sort algorithm.
      <ol>
         <li>
            <strong>Intialization: </strong> Prior to the first iteration, the 
            sub-array has just one element, and is sorted.
         </li>
         <li>
            <strong>Maintenance: </strong> After every iteration, the loop places
            the element <span class="code">A[i]</span> in its sorted position in 
            the subarray <span class="code">A[0:i]</span>. 
            Hence, after every iteration, <span class="code">i</span> is incremented 
            by one, and the subarray <span class="code">A[0:i]</span> is sorted. 
         </li>
         <li>
            <strong>Termination: </strong>Since <span class="code">i</span> keeps 
            getting incremented, it eventually equals <span class="code">num_of_elements</span> 
            and the loop condition evaluated to false. 
            After the <span class="code">(n-1)th</span> iteration, the subarray 
            <span class="code">A[0:n-1]</span>, which is the entire array, is sorted.
         </li>
      </ol>
   </div>

   <div class="ideas">
      <span class="idea-heading">Note:</span>
      To analyse an algorithm, the following two factors are taken into account:
      <ol>
         <li>
            <strong>Input size: </strong> The notion of input size depends on the
            problem being studied. It can be <em>the number of items</em>, <em>length of string</em>
            or <em>the number of nodes and edges in a graph</em>.
         </li>

         <li>
            <strong>Running time: </strong> The running time of an algorithm 
            on a particular input is the number of instructions and data 
            accesses executed.

            The running time of an algorithm on an input size of \(n\) is denoted
            by \(T(n)\).
         </li>
      </ol>

   </div>

   <div class="description">
      <span>Worst case analysis</span>
      Majority of the times, we concentrate on just the worst case analysis.
      <ol>
         <li>
            The worst-case running time of an algorithm gives an upper bound on 
            the running time for \(any\) input.
         </li>
         <li>
            For some algorithms, the worst case occurs fairly often.
         </li>
         <li>
            The "average case" is often roughly as bad as the worst case.
         </li>
      </ol>
   </div>

   <div class="ideas">
      <span class="idea-heading">Note:</span>
      It is the rate of growth, or <strong>order of growth</strong>, of the running time that really 
      interests us. We therefore consider only the leading term of a formula (e.g., \(an^{2}\) ),
      since the lower-order terms are relatively insignificant for large values of \(n\). 
      We also ignore the leading term’s constant coefûcient, since constant factors are 
      less significant than the rate of growth in determining computational efficiency 
      for large inputs.
   </div>

   <pre class="prettyprint">
//selection sort
#include &lt;stdio.h&gt;

int main() {
   int num_of_elements = 0;

   scanf("%d", &num_of_elements);

   int array[num_of_elements];

   for(int i = 0; i < num_of_elements; i++) {
      scanf("%d", &array[i]);
   }

   //array is ready

   for(int i = 0; i < (num_of_elements - 1) ; i++) {
      int smallest = array[i];
      int index = i;

      //find smallest number
      for(int j = i; j < num_of_elements; j++) {
         if(array[j] < smallest) {
            smallest = array[j];
            index = j;
         }
      }

      //exchange numbers
      int temp = array[i];
      array[i] = smallest;
      array[index] = temp;
   }

   for(int i = 0; i < num_of_elements; i++) {
      printf("%d ", array[i]);
   }

   return 0;
}
   </pre>

   <div class="question">
      <details>
         <summary>
            <ol>
               <li>
                  Analyse the running time of <em>selection sort</em>. What loop invariant
                  does this algorithm maintain?
               </li>
               <li>
                  How would you modify any sorting algorithm to have a good best-case running
                  time?
               </li>
            </ol>
         </summary>
         <p>
            \(n^2\), After every <span class="code">ith</span> iteration, the 
            first <span class="code">i</span> elements in the array are the smallest
            in the whole array <em>and</em> are sorted. 
         </p>
      </details>
   </div>

   <div class="description">
      <span>Divide and Conquer</span>
      In the divide-and-conquer method, if the problem is small enough - the <strong>base
      case</strong> - you just solve it directly without recursing. Otherwise - the <strong>recursive case</strong> - 
      you perform three characteristic steps:
      <ol>
         <li>
            <strong>Divide</strong> the problem into one or more subproblems that are smaller instances of the
            same problem.
         </li>
         <li>
            <strong>Conquer</strong> the subproblems by solving them recursively.
         </li>
         <li>
            <strong>Combine</strong> the subproblem solutions to form a solution to the original problem.
         </li>
      </ol>
   </div>





   <script src="https://cdn.jsdelivr.net/gh/google/code-prettify@master/loader/run_prettify.js"></script>
</body>
</html>